% arara: xelatex: { shell: yes, synctex: yes }
\RequirePackage[l2tabu, orthodox]{nag}
\documentclass[english,palatino]{ist-report}

\input{preamble}
\geometry{top = 1cm}
\title{Distributed Real-Time Control Systems}

\newcommand{\matr}[1]{\mathbf{#1}}
\newcommand{\ccode}[1]{\mintinline{c}{#1}}

\def\checkmark{\tikz\fill[scale=0.4](0,.35) -- (.25,0) -- (1,.7) -- (.25,.15) -- cycle;} 

\addbibresource{bibliography.bib}

\begin{document}

\begin{titlepage}

\begin{center}
	\vspace*{0.1\textheight}
	\includegraphics[width = 0.4\linewidth, trim = {172.4pt 202.7pt 172.6pt 201.4pt}, clip]{IST_A_CMYK_POS}
	
	\vspace*{0.1\textheight}
	{\huge\bfseries Real-Time Cooperative Decentralized Control of a Smart Office Illumination System}
	
	\vspace*{0.03\textheight}
	{\Large Distributed Real-Time Control Systems Final Project}
	
	\vspace*{43.5mm}
	{\Large \begin{tabular}{l r} Daniel de Schiffart & \texttt{81479} \\ João Gonçalves & \texttt{81040} \\ Francisco Castro & \texttt{78655}\end{tabular}}
	
	\vspace{\fill}
	{\large Distributed Real-Time Control Systems}
	
	\vspace*{0.01\textheight}
	{\Large Master's Degree in Aerospace Engineering}
	
	\vspace*{0.01\textheight}
	{\large Instituto Superior Técnico}
\end{center}

\end{titlepage}
\setcounter{page}{1}

{\hypersetup{linkcolor = black} \tableofcontents}

\section{Introdução}

\todo[inline]{Mencionar que toda a implementação é feita para 2 nodes, apesar de ser tudo extensível, blah blah}

\section{Raspbian Startup}
\begin{enumerate}
	\item Open console
	\item \texttt{sudo ifconfig enp2s0f0 10.0.0.2 netmask 255.255.255.0}
	\item Configure by hand on Ubuntu wired connection settings
	\begin{enumerate}
		\item Details -> Disable \textit{Connect Automatically}
		\item IPv4 -> \textit{IPv4 Method} to \textit{Manual}
		\item Set address to \texttt{10.0.0.2} and gateway to \texttt{255.255.255.0}
	\end{enumerate}
	\item Run \texttt{ssh pi\@10.0.0.1} and use \texttt{raspberry} as password
\end{enumerate}

\paragraph{Importante} Antes de desligar o Raspberry Pi, correr \texttt{sudo shutdown -h now} para evitar corrupção do sistema operativo.


\section{Illumination system calibration}

\subsection{Principles of the calibration procedure}

The illuminance at each desk follows the model
\begin{gather}
  L = K \mathbf{d} + \mathbf{o} \nonumber \\ 
  \left[\begin{array}{c} l_{1}\\ l_{2} \end{array}\right] =
  \left[\begin{array}{cc}
	k_{11} & k_{12}\\
	k_{21} & k_{22}
  \end{array}\right]
  \left[\begin{array}{c} d_{1}\\ d_{2}\end{array}\right]+
  \left[\begin{array}{c} o_{1}\\ o_{2} \end{array}\right]
  \label{eq:model}
\end{gather}
where $l_i$, $d_i$ and $o_i$ are the illuminance, LED power (in percentage) and background illuminance at desk $i$, respectively. The purpose of the calibration is to find the values for $k_{ij}$ and $o_i$ for a given office layout.

The calibration is performed by turning the lumiaires synchronously and taking measurements. One node takes initiative and sends a message to trigger the process. First, both LEDs are switched off and $o_i$ is measured.
Then, node 2 turns on its LED, measures the resulting illuminance and computes $k_{22}$, and sends the illuminance to node 1. Receiving this value, node 1 can also measure its illuminance and compute $k_{21}$. The operation inverts and $k_{12}$ and $k_{11}$ are determined. In the end, nodes share the results.

\subsection{Implementation detais}

The previous procedure is implemented as its own module, with a special communication protocol. The flow chart in figure \ref{fig:calib} illustrates messages sent and summarizes the finite-state machine.
Between changing the LED state and taking measurements, the nodes must sleep, to guarantee that the measurement is taken in steady state. For this, they were set to sleep for a lenght of time 10 times the value of the system time constant, $10 \times \SI{5}{\milli \second} = \SI{50}{\milli \second}$. 

It also should be noted that internally, the nodes are not distinguishable as 1 and 2. Each considers itself node 1 and the peer as 2, so the representation of the coupling matrix $K$ is transposed by both diagonals, and identically $o_1$ and $o_2$ are swapped.

\section{Optimização do Sistema Distribuído}

\begin{gather*}
	u^* = \textrm{argmin}\,J(x, \mu) \\
	l_i = \sum^n_{j=1} d_j k_{ij} + o_i \geq L_i, \qquad 0 \leq d_i \leq 100, \quad \forall i \\
	\matr{l} = \matr{K}\matr{d} + \matr{o} \geq \matr{L}, \qquad 0 \leq d \leq 100
\end{gather*}
Se as condições aqui listadas não forem cumpridas, o problema é declarado \textit{unfeasible}. A função de custo é
\begin{gather*}
	f(d) = c_1d_1 + c_2d_2 + \ldots + c_nd_n = \matr{C}^T\matr{d}
\end{gather*}
onde $\matr{c}$ é o vetor dos custos de energia.

Ver os cantos do domínio admissível e saber o ponto com menor custo. Assim, obtém-se $(d_1,d_2)$. Mais à frente adicionamos maximização de longevidade de lâmpadas.
\begin{figure}[ht]
	\centering
	\input{graphics/domain.tikz}
	\caption{Admissible domain and dimming value selection.}
\end{figure}


\section{Arduino data fomat}

{\centering \textit{Provisory section so that Daniel can start the web-server}}

Each Arduino sends data at every sample time so that the server can store the necessary information. 

A message is designed to be a fixed-size word, with the least number of bits possible.
Currently, the message has 20 bytes, as seen in this segment from \texttt{comms.h}:
\todo[inline]{Minted com xelatex exibe as tabs como \texttt{^^I}. E os underscores, se não fizer escape dão erros com o Tikz.}
\begin{minted}[linenos, firstnumber = 20, frame = leftline]{c}
typedef struct msg{
    MsgCode code; // 1 byte
    uint8\_t address; // 1 byte
    uint8\_t aux1; // 1 byte
    uint8\_t aux2; // 1 byte
    float value[4]; // 4 x 4 = 16 bytes

}message\_t; //size fixed to 20 bytes
\end{minted}

\ccode{code} is an unsigned integer (\ccode{uint8\_t}) which represents what the data format is.
Some values for this are used in the callibration procedure, but the value for sample time data forwarding is, for now, 5.
A way of knowing this every time is having the same \ccode{enum} in the server as in the Arduino \texttt{comms} module:
\begin{minted}[linenos, firstnumber = 9, frame = leftline]{c}
enum MsgCode : uint8\_t{

    calibration\_request,
    data,
    cont,
    acknowledge,
    consensus\_data,
    sampling\_time\_data,

};
\end{minted}

The rest of the data is:
\begin{table}[h]
  \centering
  \begin{tabular}[h]{l|l}
    \ccode{address} & Arduino's I2C address. \\
    \ccode{aux1}    & 1st MSB: Desk occupancy state (1 for occupied, 0 for free). \\
                    & next 7 bits, led duty cycle, unsigned integer from 0 to 100. \\
    \ccode{aux2}    & Illuminance lower bound (presumably 40 or 80), in LUX. \\
    \ccode{value[0]}& Measured illuminance, in LUX. \\
    \ccode{value[1]}& Local background illuminance, in LUX. \\
    \ccode{value[2]}& Instantaneous control illuminance reference, in LUX. \\
    \ccode{value[3]}& Instantaneous power consumption, units to be defined. 
  \end{tabular}
\end{table}

Note, to extract the duty cycle and occupancy state, you can do:
\begin{minted}[]{c}
  unsigned duty\_cycle = aux1 & (0x7F); // This is a bit-wise and with 0111111
  bool state = aux1 & (0x80); // This is a bit-wise and with 10000000 
\end{minted}

From what I see, this is everything we need to send the server, and it should be able to compute the necessary variables. The following table should summarize my thoughts:
\begin{table}[h]
  \centering
  \begin{tabularx}{\linewidth}{l|X}
	Quantity & How to determine (\checkmark means it is sent every sample time) \\
	Illuminance & \checkmark \\
	duty cycle  & \checkmark \\
	occupancy state & \checkmark \\
	lower bound & \checkmark \\
	Control reference & \checkmark \\
	Background illuminance & \checkmark \\
	Instantaneous power consumption & \checkmark \\
	Total power consumption & Sum of instantaneous power consumption for all nodes. \\
	Time since last restart & listen to a specific message code (to be defined) and keep the timestamp. \\
	Node energy spent since last restart & integrate node's instantaneous power consumption, sample time is fixed and known. \\
	Total energy since last restart & Sum both nodes's energy spent. \\
	Node confort error since last restart & At each sample time we have the lower bound and the illuminance, do the math. \\
	Total confort error since last restart & Sum both nodes' confort error. \\
	Node flicker since last restart & See project description, all that is needed is the illuminance from the last 3 samples. \\
	Total flicker since last restart & Sum both nodes' flicker.
  \end{tabularx}
\end{table}

I might have missed something, we'll see.

\appendix
\section{Esquemas}

\begin{figure}[ht]
	\centering
	\input{graphics/setup.tikz}
	\caption{Arduino and Raspberry Pi setup.}
\end{figure}

\begin{figure}[ht]
	\centering
	\input{graphics/calib.tikz}
	\caption{Calibration procedure.}
	\label{fig:calib}
\end{figure}

\pagebreak
\printbibliography

\listoftodos
\end{document}
